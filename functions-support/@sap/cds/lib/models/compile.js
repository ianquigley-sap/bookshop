const cdsv = require('./cdsv')
const cds = require('../cds')
const $ = Object.assign
const YAML = { stringify: (...args) => (YAML.stringify = require('./2yaml'))(...args) }
// alpha fixes for gaps
const {unfold:_unfold_localized} = require ('../alpha/_localized')
// const {unfold:_unfold_temporal} = require ('../alpha/_temporal')
const DEBUG = process.env.DEBUG_COMPILE && console.warn

const compile = (csn) => ({
  for:(x,o) => _fluent (compile_for,x, csn,o),
  to:(x,o) => _fluent (compile_to,x, csn,o),
})

// Fluent API, i.e. compile(csn).to('yml') --> see also: https://bit.ly/capire/APIs#cds-compile)
function _fluent (compile_, to_or_for, csn, o) {
    let fn = compile_[to_or_for];  if (!fn)  throw new TypeError (`cds.compile.for.${to_or_for} is not defined`)
    if (typeof csn === 'string')  csn = cds.parse (csn)
    return fn (csn,o)
}

// Dedicated API, i.e. compile.for.odata(csn)
const compile_for = {
  odata: (csn,o) => { // we cache because cds-services calls us for every single service in a model
    const cached = csn._4odata; if (cached) return cached
    const csn4 = cdsv.forOData (csn,o);  /* cache it: */ Object.defineProperty (csn, '_4odata', {value: csn4})
    return $(csn4, { '@sql_mapping': o && o.sql_mapping || cds.env.sql_mapping })
  },
  sql: (csn,o) => cdsv.forSql (csn,o),
}

// Dedicated API, i.e. compile.to.yml('csn')
const compile_to = {
  yaml: YAML.stringify, yml: YAML.stringify,
  json: x => JSON.stringify(x,null,2),
  edmx: (csn,o) => _2edm (csn,o, {off: 'metadata', only: 'annotations'}[o && o.annos]),
  edm: (csn,o) => _2edm (csn,o, 'metadata_json'),
  annos: (csn,o) => _2edm (csn,o, 'annotations'),
  swgr: (csn,o) => _2many  (cdsv.toSwagger(csn,o).services, '.swgr.json'),
  cdl: (csn,o) => _2many (cdsv.toCdl(csn,o),'.cds'),
  sql: (csn,o) => _2sql (_unfold_localized (_sql (cdsv.toSql (_skipUnused(csn),o)), csn, o), o),
  hana: (csn,o) => _2many (cdsv.toHana(_skipUnused(csn),o).hdbcds, '.hdbcds'),
  xsuaa: (csn,o) => require('./xsuaa').xsuaaConfig (csn,o)
}


/** Skip unused entities marked with @cds.persistence.skip:'if-unused' */
function _skipUnused (csn) { // NOSONAR

  const m = cds.linked (csn)
  const services = RegExp (Object.keys (m.services).map(n => '^'+n+'\\.').join('|'))
  const localized_ = /^localized\./

  // for each entity e1 marked with @cds.persistence.skip:'if-unused'...
  m.foreach (e => !e.abstract && e['@cds.persistence.skip']=='if-unused', e1 => { // NOSONAR
    if (localized_.test(e1.name))  return
    if (services.test(e1.name))  return
    // fetch other entities e2 that contain references to e1 ...
    for (let e2 of m.each(cds.entity)) {
      if (e2 === e1)  continue
      if (localized_.test(e2.name))  continue  // ignore ref from derived entities
        // is e2 a view on e1?
      const q = e2.query; if (q && q.target === e1) { // found reference
        return DEBUG && DEBUG (`NOT skipping ${e1.name} due to view ${e2.name}`)
      }
      const x = e2.includes; if (x && x.includes (e1.name))  { // found reference
        return DEBUG && DEBUG (`NOT skipping ${e1.name} due to ${e2.name}`)
      }
      // does e2 contain Associations to e1?
      for (let e in e2.elements) {
        let a = e2.elements[e]
        if (a._target === e1) { // found reference
          return DEBUG && DEBUG (`NOT skipping ${e1.name} due to ${e2.name}[${a.name}]`)
        }
      }
    }
    // skip e1 if no fererences have been found
    skip (e1.name)
  })

  function skip (entry) {
    if (csn.definitions [entry]) {
      DEBUG && DEBUG (`Skipping ${entry}`)
      delete csn.definitions [entry]
      if (csn._xsn)  delete csn._xsn.definitions [entry]
      if (!/_texts$/.test(entry))  skip (entry+'_texts')
      if (!localized_.test(entry))  skip ('localized.'+entry)
    }
  }

  return csn
}

/** Return output of 2hana as an iterable */
function* _2many (result, suffix='.hdbcds') {
  for (let each in result) yield [result[each], // content
    { name: each.replace(/[.:/\\]/g, '_'), suffix }
  ]
}

// TODO: remove that from cdsc
function _sql ({sql}) {
  const all=[]
  for (let e in sql)  all.push (sql[e].replace(/-- generated by.*\n/,'').replace(/;$/, ''))
  return all
}

/** Return output of 2sql as array of ddl statements or a concatenated string of which */
function _2sql (all, _o) {
  if (_o && _o.as === 'str') return '\n'+ all.join(';\n\n') +';\n'
  else return all
}

/** Return output of 2edm/x as a single json object or edmx string or as an iterable for all of which */
function _2edm (csn, o={}, what='combined') { // NOSONAR

  if (what === 'combined')  o.combined = true;  else o.separate = true
  if (what === 'metadata_json')  o.json = true;  else o.xml = true
  if (!o.version)  o.version = o.json ? 'v4' : cds.env.odata.version

  const {services} = cdsv.toOdata(csn,o) || {}
  const chosen = o.service

  if (chosen === 'all') { //> all services
    const all = function*(){ for (let s in services)  yield [ _result(s), {name:s} ] }
    return all()
  } else if (chosen) { //> a specific service
    const one = Object.keys(services).find (n => n.indexOf(chosen) >= 0)
    return one ? _result(one) : _not_found (chosen)
  } else { //> a single service
    const [one,many] = Object.keys(services)
    return many ? _choose_one_of(services) : _result(one)
  }

  function _result (name) {
    if (Object.keys(services).length === 0)  throw new Error('No service definitions found')
    const x = services[name][what]
    return o.as === 'str' && typeof x !== 'string' ? JSON.stringify(x) : x
  }
  function _choose_one_of (all) {
    throw new Error (`[cds] - multiple service definitions found in model; add one of...\n
    -s all ${Object.keys(all).map (each => `\n    -s ${each}`).join('')} \n`)
  }
  function _not_found (name) {
    if (Object.keys(services).length === 0)  throw new Error('No service definitions found')
    throw new Error (`[cds] - no service definition matching '${name}' found among...
    ${Object.keys(services).map (each => `\n   ${each}`).join('')} \n`)
  }

}


module.exports = Object.assign (compile, { to: compile_to, for: compile_for })

/* eslint no-console:off */
